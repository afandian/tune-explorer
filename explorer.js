// Generated by CoffeeScript 1.6.2
/*
Folk Tune Finder tune explorer!

Code for drawing keyboards, typesetting staves, plotting melody trees.

Copyright Joe Wass 2011 - 2013
joe@afandian.com
*/


(function() {
  var ACCIDENTAL, CanvasKeyboardAdaptor, CanvasRenderer, Context, Keyboard, KeyboardAdaptor, KeyboardDrawer, MIDDLE_C, Theory, adaptor, canvas, context, keyboard, keyboardDrawer, renderer, theory,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  ACCIDENTAL = {
    SHARP: 's',
    FLAT: 'f',
    NATURAL: 'n'
  };

  MIDDLE_C = 60;

  Theory = (function() {
    function Theory() {
      this.DIATONIC_DEGREES = {
        0: [
          {
            degree: 0,
            accidental: ACCIDENTAL.NATURAL
          }
        ],
        1: [
          {
            degree: 0,
            accidental: ACCIDENTAL.SHARP
          }, {
            degree: 1,
            accidental: ACCIDENTAL.FLAT
          }
        ],
        2: [
          {
            degree: 1,
            accidental: ACCIDENTAL.NATURAL
          }
        ],
        3: [
          {
            degree: 2,
            accidental: ACCIDENTAL.FLAT
          }, {
            degree: 1,
            accidental: ACCIDENTAL.SHARP
          }
        ],
        4: [
          {
            degree: 2,
            accidental: ACCIDENTAL.NATURAL
          }
        ],
        5: [
          {
            degree: 3,
            accidental: ACCIDENTAL.NATURAL
          }
        ],
        6: [
          {
            degree: 3,
            accidental: ACCIDENTAL.SHARP
          }, {
            degree: 4,
            accidental: ACCIDENTAL.FLAT
          }
        ],
        7: [
          {
            degree: 4,
            accidental: ACCIDENTAL.NATURAL
          }
        ],
        8: [
          {
            degree: 4,
            accidental: ACCIDENTAL.SHARP
          }, {
            degree: 5,
            accidental: ACCIDENTAL.FLAT
          }
        ],
        9: [
          {
            degree: 5,
            accidental: ACCIDENTAL.NATURAL
          }
        ],
        10: [
          {
            degree: 6,
            accidental: ACCIDENTAL.FLAT
          }, {
            degree: 5,
            accidental: ACCIDENTAL.SHARP
          }
        ],
        11: [
          {
            degree: 6,
            accidental: ACCIDENTAL.NATURAL
          }
        ]
      };
      this.DIATONIC_NOTE_NAMES = ["C", "D", "E", "F", "G", "A", "B"];
    }

    Theory.prototype.positionRelativeToPitch = function(givenPitch, relativeTo) {
      var absPitch, degree, diatonicAccidental, diatonicDegree, diatonicRelative, octave, relativeOctave;

      absPitch = givenPitch;
      while (absPitch < relativeTo) {
        absPitch += 12;
      }
      degree = Math.abs((relativeTo - absPitch) % 12);
      diatonicDegree = this.DIATONIC_DEGREES[degree][0].degree;
      diatonicAccidental = this.DIATONIC_DEGREES[degree][0].accidental;
      relativeOctave = Math.floor((givenPitch - relativeTo) / 12);
      diatonicRelative = relativeOctave * 7 + diatonicDegree;
      octave = Math.floor(givenPitch / 12);
      return {
        chromaticDegree: degree,
        chromaticAbsolute: givenPitch,
        diatonicDegree: diatonicDegree,
        diatonicAccidental: diatonicAccidental,
        diatonicRelative: diatonicRelative,
        octave: octave
      };
    };

    Theory.prototype.noteName = function(pitch) {
      var contextualDegree, name;

      contextualDegree = theory.positionRelativeToPitch(pitch, MIDDLE_C);
      name = this.DIATONIC_NOTE_NAMES[contextualDegree.diatonicDegree];
      name = name + (contextualDegree.diatonicAccidental === ACCIDENTAL.SHARP ? "#" : contextualDegree.diatonicAccidental === ACCIDENTAL.FLAT ? "b" : "");
      return name;
    };

    return Theory;

  })();

  theory = new Theory;

  KeyboardDrawer = (function() {
    function KeyboardDrawer(keyboard) {
      this.keyboard = keyboard;
    }

    KeyboardDrawer.prototype.draw = function(adaptor) {
      var pitch, _i, _ref, _ref1, _results;

      adaptor.range(this.keyboard.LOWEST_PITCH, this.keyboard.HIGHEST_PITCH);
      _results = [];
      for (pitch = _i = _ref = this.keyboard.LOWEST_PITCH, _ref1 = this.keyboard.HIGHEST_PITCH; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; pitch = _ref <= _ref1 ? ++_i : --_i) {
        _results.push(adaptor.key(pitch));
      }
      return _results;
    };

    return KeyboardDrawer;

  })();

  KeyboardAdaptor = (function() {
    function KeyboardAdaptor() {}

    return KeyboardAdaptor;

  })();

  CanvasKeyboardAdaptor = (function(_super) {
    __extends(CanvasKeyboardAdaptor, _super);

    function CanvasKeyboardAdaptor(keyboardDrawer, WHITE_NOTE_WIDTH, BLACK_NOTE_WIDTH, WHITE_NOTE_HEIGHT, BLACK_NOTE_HEIGHT) {
      this.keyboardDrawer = keyboardDrawer;
      this.WHITE_NOTE_WIDTH = WHITE_NOTE_WIDTH;
      this.BLACK_NOTE_WIDTH = BLACK_NOTE_WIDTH;
      this.WHITE_NOTE_HEIGHT = WHITE_NOTE_HEIGHT;
      this.BLACK_NOTE_HEIGHT = BLACK_NOTE_HEIGHT;
      this.BLACK_NOTE_OFFSET_S = this.WHITE_NOTE_WIDTH - this.BLACK_NOTE_WIDTH / 2;
      this.BLACK_NOTE_OFFSET_F = -this.BLACK_NOTE_WIDTH / 2;
    }

    CanvasKeyboardAdaptor.prototype.range = function(lowestPitch, highestPitch) {
      this.lowestPitch = lowestPitch;
      return this.highestPitch = highestPitch;
    };

    CanvasKeyboardAdaptor.prototype.draw = function(graphicsContext) {
      this.graphicsContext = graphicsContext;
      this.drawCallbackmode = 0;
      this.keyboardDrawer.draw(this);
      this.drawCallbackmode = 1;
      return this.keyboardDrawer.draw(this);
    };

    CanvasKeyboardAdaptor.prototype.key = function(pitch) {
      var contextualDegree, octaveOffset, x;

      contextualDegree = theory.positionRelativeToPitch(pitch, MIDDLE_C);
      octaveOffset = contextualDegree.octave * 7 * this.WHITE_NOTE_WIDTH;
      if (this.drawCallbackmode === 0 && contextualDegree.diatonicAccidental === ACCIDENTAL.NATURAL) {
        this.graphicsContext.fillStyle = "rgba(240, 240, 240, 1)";
        this.graphicsContext.strokeStyle = "rgba(10, 10, 10, 1)";
        this.graphicsContext.lineWidth = 1;
        x = octaveOffset + contextualDegree.diatonicDegree * this.WHITE_NOTE_WIDTH;
        this.graphicsContext.fillRect(x, 0, this.WHITE_NOTE_WIDTH, this.WHITE_NOTE_HEIGHT);
        return this.graphicsContext.strokeRect(x, 0, this.WHITE_NOTE_WIDTH, this.WHITE_NOTE_HEIGHT);
      } else if (contextualDegree.diatonicAccidental === ACCIDENTAL.SHARP) {
        this.graphicsContext.fillStyle = "rgba(10, 10, 10, 1)";
        this.graphicsContext.strokeStyle = "rgba(40, 40, 40, 1)";
        this.graphicsContext.lineWidth = 4;
        x = octaveOffset + contextualDegree.diatonicDegree * this.WHITE_NOTE_WIDTH;
        this.graphicsContext.fillRect(x + this.BLACK_NOTE_OFFSET_S, 0, this.BLACK_NOTE_WIDTH, this.BLACK_NOTE_HEIGHT);
        return this.graphicsContext.strokeRect(x + this.BLACK_NOTE_OFFSET_S, 0, this.BLACK_NOTE_WIDTH, this.BLACK_NOTE_HEIGHT);
      } else if (contextualDegree.diatonicAccidental === ACCIDENTAL.FLAT) {
        this.graphicsContext.fillStyle = "rgba(10, 10, 10, 1)";
        this.graphicsContext.strokeStyle = "rgba(40, 40, 40, 1)";
        this.graphicsContext.lineWidth = 4;
        x = octaveOffset + (contextualDegree.diatonicDegree + 1) * this.WHITE_NOTE_WIDTH;
        this.graphicsContext.fillRect(x + this.BLACK_NOTE_OFFSET_F, 0, this.BLACK_NOTE_WIDTH, this.BLACK_NOTE_HEIGHT);
        return this.graphicsContext.strokeRect(x + this.BLACK_NOTE_OFFSET_F, 0, this.BLACK_NOTE_WIDTH, this.BLACK_NOTE_HEIGHT);
      }
    };

    return CanvasKeyboardAdaptor;

  })(KeyboardAdaptor);

  /*
  
  # A keyboard adaptor that creates HTML elements.
  class ElementKeyboardAdaptor extends KeyboardAdaptor
    constructor : (@keyboard, @$container, @WHITE_NOTE_WIDTH, @BLACK_NOTE_WIDTH, @WHITE_NOTE_HEIGHT, @BLACK_NOTE_HEIGHT) ->
  
      @$container.css("height", @WHITE_NOTE_HEIGHT)
      @$container.parent().css("height", @WHITE_NOTE_HEIGHT)
  
      @BLACK_HINT = 1
      @BLACK_NOTE_OFFSET = @WHITE_NOTE_WIDTH - (@BLACK_NOTE_WIDTH / 2)
  
    # Draw the keyboard!
    draw : () ->
      @x = 0
      @keyboard.draw(this)
  
  
    # Draw a key. Callback from draw().
    key : (pitch) -> 
          contextualDegree = theory.positionRelativeToPitch(pitch, MIDDLE_C)
  
          $key = $("<div></div>")
          $key.css("position", "absolute")
          $key.css("top", 0)
          $key.css("cursor", "hand")
  
          $key_label = $("<div></div>")
          $key_label.css("position", "absolute")
          $key_label.css("bottom", "0px")
  
          $key_label.css("-webkit-user-select", "none")
          $key_label.css("-khtml-user-select", "none")
          $key_label.css("-moz-user-select", "none")
          $key_label.css("-o-user-select", "none")
          $key_label.css("user-select", "none")
  
          $key_label.css("text-align", "center")
          $key_label.css("cursor", "hand")
  
          if contextualDegree.diatonicAccidental == ACCIDENTAL.NATURAL
            @x = @x + @WHITE_NOTE_WIDTH
            $key.css("background-color", "white")
            $key.css("color", "black")
            $key.css("border", "1px solid #e0e0e0")
            $key.css("height", @WHITE_NOTE_HEIGHT)
            $key.css("width", @WHITE_NOTE_WIDTH)
            $key.css("left", @x)
            $key.css("z-index", 1)
  
            $key_label.css("width", @WHITE_NOTE_WIDTH)
          else
            # Black note
            $key.css("background-color", "black")
            $key.css("color", "white")
            $key.css("border", "1px solid #a0a0a0")
            $key.css("height", @BLACK_NOTE_HEIGHT)
            $key.css("width", @BLACK_NOTE_WIDTH)
  
            $key.css("-webkit-border-bottom-right-radius", "4px")
            $key.css("-webkit-border-bottom-left-radius", "4px")
            $key.css("-moz-border-radius-bottomright", "4px")
            $key.css("-moz-border-radius-bottomleft", "4px")
            $key.css("border-bottom-right-radius", "4px")
            $key.css("border-bottom-left-radius", "4px")
  
            $key.css("z-index", 2)
  
            if contextualDegree.chromaticDegree == 6 || contextualDegree.chromaticDegree == 1
                $key.css("left", (@x + @BLACK_NOTE_OFFSET) + @BLACK_HINT)
            else if contextualDegree.chromaticDegree == 10 || contextualDegree.chromaticDegree == 3
                $key.css("left", (@x + @BLACK_NOTE_OFFSET) - @BLACK_HINT)
            else
                $key.css("left", @x + @BLACK_NOTE_OFFSET)
  
          $key_label.css("width", @BLACK_NOTE_WIDTH)
  
          $key_label.html(theory.noteName(pitch))
          $key.append($key_label)
  
          @$container.append($key)
  */


  Keyboard = (function() {
    function Keyboard(LOWEST_PITCH, HIGHEST_PITCH) {
      this.LOWEST_PITCH = LOWEST_PITCH;
      this.HIGHEST_PITCH = HIGHEST_PITCH;
    }

    return Keyboard;

  })();

  Context = (function() {
    function Context(renderer) {
      this.renderer = renderer;
      this.renderer.render;
    }

    Context.prototype.run = function() {
      return this.renderer.renderLoop();
    };

    Context.prototype.tick = function() {};

    return Context;

  })();

  CanvasRenderer = (function() {
    function CanvasRenderer(canvas, keyboardDrawAdaptor) {
      this.canvas = canvas;
      this.keyboardDrawAdaptor = keyboardDrawAdaptor;
      this.renderLoop = __bind(this.renderLoop, this);
      this.canvasSize();
      this.requestFrame = (function() {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function() {
          return window.setTimeout(callback, 1000 / 60);
        };
      })();
    }

    CanvasRenderer.prototype.canvasSize = function() {
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
      this.context = this.canvas.getContext("2d");
      return window.addEventListener('resize', this.canvasSize, false);
    };

    CanvasRenderer.prototype.render = function() {
      this.context.save();
      this.context.setTransform(1, 0, 0, 1, 0, 0);
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.context.restore();
      return this.keyboardDrawAdaptor.draw(this.context);
    };

    CanvasRenderer.prototype.renderLoop = function() {
      this.render();
      return this.requestFrame.call(window, this.renderLoop);
    };

    return CanvasRenderer;

  })();

  keyboard = new Keyboard(0, 127);

  keyboardDrawer = new KeyboardDrawer(keyboard);

  canvas = document.getElementById("canvas");

  adaptor = new CanvasKeyboardAdaptor(keyboardDrawer, 20, 8, 100, 50);

  renderer = new CanvasRenderer(canvas, adaptor);

  context = new Context(renderer);

  context.run();

}).call(this);
