// Generated by CoffeeScript 1.6.2
/*
Folk Tune Finder tune explorer!

Code for drawing keyboards, typesetting staves, plotting melody trees.

Copyright Joe Wass 2011 - 2013
joe@afandian.com
*/


(function() {
  var ACCIDENTAL, CanvasKeyboardAdaptor, CanvasRenderer, Context, Keyboard, KeyboardAdaptor, KeyboardDrawer, MIDDLE_C, Theory, adaptor, canvas, context, keyboard, keyboardDrawer, renderer, theory,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  ACCIDENTAL = {
    SHARP: 's',
    FLAT: 'f',
    NATURAL: 'n'
  };

  MIDDLE_C = 60;

  Theory = (function() {
    function Theory() {
      this.DIATONIC_DEGREES = {
        0: [
          {
            degree: 0,
            accidental: ACCIDENTAL.NATURAL
          }
        ],
        1: [
          {
            degree: 0,
            accidental: ACCIDENTAL.SHARP
          }, {
            degree: 1,
            accidental: ACCIDENTAL.FLAT
          }
        ],
        2: [
          {
            degree: 1,
            accidental: ACCIDENTAL.NATURAL
          }
        ],
        3: [
          {
            degree: 2,
            accidental: ACCIDENTAL.FLAT
          }, {
            degree: 1,
            accidental: ACCIDENTAL.SHARP
          }
        ],
        4: [
          {
            degree: 2,
            accidental: ACCIDENTAL.NATURAL
          }
        ],
        5: [
          {
            degree: 3,
            accidental: ACCIDENTAL.NATURAL
          }
        ],
        6: [
          {
            degree: 3,
            accidental: ACCIDENTAL.SHARP
          }, {
            degree: 4,
            accidental: ACCIDENTAL.FLAT
          }
        ],
        7: [
          {
            degree: 4,
            accidental: ACCIDENTAL.NATURAL
          }
        ],
        8: [
          {
            degree: 4,
            accidental: ACCIDENTAL.SHARP
          }, {
            degree: 5,
            accidental: ACCIDENTAL.FLAT
          }
        ],
        9: [
          {
            degree: 5,
            accidental: ACCIDENTAL.NATURAL
          }
        ],
        10: [
          {
            degree: 6,
            accidental: ACCIDENTAL.FLAT
          }, {
            degree: 5,
            accidental: ACCIDENTAL.SHARP
          }
        ],
        11: [
          {
            degree: 6,
            accidental: ACCIDENTAL.NATURAL
          }
        ]
      };
      this.DIATONIC_NOTE_NAMES = ["C", "D", "E", "F", "G", "A", "B"];
    }

    Theory.prototype.positionRelativeToPitch = function(givenPitch, relativeTo) {
      var absPitch, degree, diatonicAccidental, diatonicDegree, diatonicRelative, octave, relativeOctave;

      absPitch = givenPitch;
      while (absPitch < relativeTo) {
        absPitch += 12;
      }
      degree = Math.abs((relativeTo - absPitch) % 12);
      diatonicDegree = this.DIATONIC_DEGREES[degree][0].degree;
      diatonicAccidental = this.DIATONIC_DEGREES[degree][0].accidental;
      relativeOctave = Math.floor((givenPitch - relativeTo) / 12);
      diatonicRelative = relativeOctave * 7 + diatonicDegree;
      octave = Math.floor(givenPitch / 12);
      return {
        chromaticDegree: degree,
        chromaticAbsolute: givenPitch,
        diatonicDegree: diatonicDegree,
        diatonicAccidental: diatonicAccidental,
        diatonicRelative: diatonicRelative,
        octave: octave
      };
    };

    Theory.prototype.noteName = function(pitch) {
      var contextualDegree, name;

      contextualDegree = theory.positionRelativeToPitch(pitch, MIDDLE_C);
      name = this.DIATONIC_NOTE_NAMES[contextualDegree.diatonicDegree];
      name = name + (contextualDegree.diatonicAccidental === ACCIDENTAL.SHARP ? "#" : contextualDegree.diatonicAccidental === ACCIDENTAL.FLAT ? "b" : "");
      return name;
    };

    return Theory;

  })();

  theory = new Theory;

  KeyboardDrawer = (function() {
    function KeyboardDrawer(keyboard) {
      this.keyboard = keyboard;
    }

    KeyboardDrawer.prototype.draw = function(adaptor) {
      var pitch, _i, _ref, _ref1, _results;

      adaptor.range(this.keyboard.LOWEST_PITCH, this.keyboard.HIGHEST_PITCH);
      _results = [];
      for (pitch = _i = _ref = this.keyboard.LOWEST_PITCH, _ref1 = this.keyboard.HIGHEST_PITCH; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; pitch = _ref <= _ref1 ? ++_i : --_i) {
        _results.push(adaptor.key(pitch));
      }
      return _results;
    };

    return KeyboardDrawer;

  })();

  KeyboardAdaptor = (function() {
    function KeyboardAdaptor() {}

    return KeyboardAdaptor;

  })();

  CanvasKeyboardAdaptor = (function(_super) {
    __extends(CanvasKeyboardAdaptor, _super);

    function CanvasKeyboardAdaptor(keyboardDrawer, WHITE_NOTE_WIDTH, BLACK_NOTE_WIDTH, WHITE_NOTE_HEIGHT, BLACK_NOTE_HEIGHT) {
      this.keyboardDrawer = keyboardDrawer;
      this.WHITE_NOTE_WIDTH = WHITE_NOTE_WIDTH;
      this.BLACK_NOTE_WIDTH = BLACK_NOTE_WIDTH;
      this.WHITE_NOTE_HEIGHT = WHITE_NOTE_HEIGHT;
      this.BLACK_NOTE_HEIGHT = BLACK_NOTE_HEIGHT;
      this.keyOffset = __bind(this.keyOffset, this);
      this.BLACK_NOTE_OFFSET_S = this.WHITE_NOTE_WIDTH - this.BLACK_NOTE_WIDTH / 2;
      this.BLACK_NOTE_OFFSET_F = this.WHITE_NOTE_WIDTH - this.BLACK_NOTE_WIDTH / 2;
      this.MIDDLE_C_MARKER_RADIUS = this.WHITE_NOTE_WIDTH / 4;
    }

    CanvasKeyboardAdaptor.prototype.range = function(lowestPitch, highestPitch) {
      this.lowestPitch = lowestPitch;
      this.highestPitch = highestPitch;
      return this.keyboardOffset = -this.keyOffset(lowestPitch);
    };

    CanvasKeyboardAdaptor.prototype.draw = function(graphicsContext) {
      var middleCX;

      this.graphicsContext = graphicsContext;
      this.drawCallbackmode = 0;
      this.graphicsContext.fillStyle = "rgba(240, 240, 240, 1)";
      this.graphicsContext.strokeStyle = "rgba(10, 10, 10, 1)";
      this.graphicsContext.lineWidth = 1;
      this.keyboardDrawer.draw(this);
      this.drawCallbackmode = 1;
      this.graphicsContext.fillStyle = "rgba(10, 10, 10, 1)";
      this.graphicsContext.strokeStyle = "rgba(40, 40, 40, 1)";
      this.graphicsContext.lineWidth = 1;
      this.keyboardDrawer.draw(this);
      if ((this.lowestPitch <= 60 && 60 <= this.highestPitch)) {
        middleCX = this.keyOffset(60) + this.keyboardOffset;
        graphicsContext.fillStyle = "rgba(0,0,0,0.25)";
        graphicsContext.lineWidth = 1;
        graphicsContext.strokeStyle = "rgba(0,0,0,0,0.125)";
        graphicsContext.beginPath();
        graphicsContext.arc(middleCX + this.WHITE_NOTE_WIDTH / 2, this.WHITE_NOTE_HEIGHT * 0.75, this.MIDDLE_C_MARKER_RADIUS, 0, 2 * Math.PI, false);
        graphicsContext.fill();
        return graphicsContext.stroke();
      }
    };

    CanvasKeyboardAdaptor.prototype.key = function(pitch) {
      var contextualDegree, x;

      contextualDegree = theory.positionRelativeToPitch(pitch, MIDDLE_C);
      x = this.keyOffset(pitch) + this.keyboardOffset;
      if (this.drawCallbackmode === 0) {
        if (contextualDegree.diatonicAccidental === ACCIDENTAL.NATURAL) {
          this.graphicsContext.fillRect(x, 0, this.WHITE_NOTE_WIDTH, this.WHITE_NOTE_HEIGHT);
          return this.graphicsContext.strokeRect(x, 0, this.WHITE_NOTE_WIDTH, this.WHITE_NOTE_HEIGHT);
        }
      } else {
        if (contextualDegree.diatonicAccidental === ACCIDENTAL.SHARP) {
          this.graphicsContext.fillRect(x + this.BLACK_NOTE_OFFSET_S, 0, this.BLACK_NOTE_WIDTH, this.BLACK_NOTE_HEIGHT);
          return this.graphicsContext.strokeRect(x + this.BLACK_NOTE_OFFSET_S, 0, this.BLACK_NOTE_WIDTH, this.BLACK_NOTE_HEIGHT);
        } else if (contextualDegree.diatonicAccidental === ACCIDENTAL.FLAT) {
          this.graphicsContext.fillRect(x + this.BLACK_NOTE_OFFSET_F, 0, this.BLACK_NOTE_WIDTH, this.BLACK_NOTE_HEIGHT);
          return this.graphicsContext.strokeRect(x + this.BLACK_NOTE_OFFSET_F, 0, this.BLACK_NOTE_WIDTH, this.BLACK_NOTE_HEIGHT);
        }
      }
    };

    CanvasKeyboardAdaptor.prototype.keyOffset = function(pitch) {
      var contextualDegree, octaveOffset;

      contextualDegree = theory.positionRelativeToPitch(pitch, MIDDLE_C);
      octaveOffset = contextualDegree.octave * 7 * this.WHITE_NOTE_WIDTH;
      if (contextualDegree.diatonicAccidental === ACCIDENTAL.NATURAL) {
        return octaveOffset + contextualDegree.diatonicDegree * this.WHITE_NOTE_WIDTH;
      } else if (contextualDegree.diatonicAccidental === ACCIDENTAL.SHARP) {
        return octaveOffset + contextualDegree.diatonicDegree * this.WHITE_NOTE_WIDTH;
      } else if (contextualDegree.diatonicAccidental === ACCIDENTAL.FLAT) {
        return octaveOffset + (contextualDegree.diatonicDegree - 1) * this.WHITE_NOTE_WIDTH;
      }
    };

    return CanvasKeyboardAdaptor;

  })(KeyboardAdaptor);

  Keyboard = (function() {
    function Keyboard(LOWEST_PITCH, HIGHEST_PITCH) {
      this.LOWEST_PITCH = LOWEST_PITCH;
      this.HIGHEST_PITCH = HIGHEST_PITCH;
    }

    return Keyboard;

  })();

  Context = (function() {
    function Context(renderer) {
      this.renderer = renderer;
      this.renderer.render;
    }

    Context.prototype.run = function() {
      return this.renderer.renderLoop();
    };

    Context.prototype.tick = function() {};

    return Context;

  })();

  CanvasRenderer = (function() {
    function CanvasRenderer(canvas, keyboardDrawAdaptor) {
      this.canvas = canvas;
      this.keyboardDrawAdaptor = keyboardDrawAdaptor;
      this.renderLoop = __bind(this.renderLoop, this);
      this.canvasSize();
      this.requestFrame = (function() {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function() {
          return window.setTimeout(callback, 1000 / 60);
        };
      })();
    }

    CanvasRenderer.prototype.canvasSize = function() {
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
      this.context = this.canvas.getContext("2d");
      return window.addEventListener('resize', this.canvasSize, false);
    };

    CanvasRenderer.prototype.render = function() {
      this.context.save();
      this.context.setTransform(1, 0, 0, 1, 0, 0);
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.context.restore();
      return this.keyboardDrawAdaptor.draw(this.context);
    };

    CanvasRenderer.prototype.renderLoop = function() {
      this.render();
      return this.requestFrame.call(window, this.renderLoop);
    };

    return CanvasRenderer;

  })();

  keyboard = new Keyboard(60 - (12 * 2), 60 + (12 * 2));

  keyboardDrawer = new KeyboardDrawer(keyboard);

  canvas = document.getElementById("canvas");

  adaptor = new CanvasKeyboardAdaptor(keyboardDrawer, 20, 8, 100, 50);

  renderer = new CanvasRenderer(canvas, adaptor);

  context = new Context(renderer);

  context.run();

}).call(this);
